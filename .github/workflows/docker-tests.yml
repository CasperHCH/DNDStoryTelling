name: Docker Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  docker-build-test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]

    steps:
    - uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Set up QEMU for ARM64 emulation
      if: matrix.platform == 'linux/arm64'
      uses: docker/setup-qemu-action@v3
      with:
        platforms: arm64

    - name: Build Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: deployment/docker/Dockerfile
        platforms: ${{ matrix.platform }}
        push: false
        tags: dndstorytelling:test
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          OPENAI_API_KEY=test_key
          DATABASE_URL=postgresql+asyncpg://user:password@db:5432/dndstory

  docker-compose-test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Create test environment file
      run: |
        cp configuration/.env.docker.test .env || echo "ENVIRONMENT=test" > .env
        echo "CONFLUENCE_API_TOKEN=test_confluence_token" >> .env
        echo "CONFLUENCE_URL=https://test.atlassian.net" >> .env
        echo "SECRET_KEY=test_secret_key_for_docker_testing_12345" >> .env

    - name: Build and start services
      run: |
        docker compose up -d --build

    - name: Wait for services to be ready
      run: |
        # Wait for database
        timeout=60
        while ! docker compose exec -T db pg_isready -U user -d dndstory; do
          sleep 2
          timeout=$((timeout - 2))
          if [ $timeout -le 0 ]; then
            echo "Database failed to start"
            docker compose logs db
            exit 1
          fi
        done

        # Wait for web service
        timeout=60
        while ! curl -f http://localhost:8001/health 2>/dev/null; do
          sleep 2
          timeout=$((timeout - 2))
          if [ $timeout -le 0 ]; then
            echo "Web service failed to start"
            docker compose logs web
            exit 1
          fi
        done

    - name: Test application endpoints
      run: |
        # Test health endpoint
        curl -f http://localhost:8001/health || curl -f http://localhost:8001/

        # Test static files (if they exist)
        curl -I http://localhost:8001/static/ || echo "No static files endpoint"

    - name: Run database migrations test
      run: |
        # Test that Alembic migrations work
        docker compose exec -T web alembic current || echo "No migrations configured yet"

    - name: Test container resource usage
      run: |
        # Check memory and CPU usage (important for NAS deployment)
        docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"

        # Log container sizes
        docker images dndstorytelling_web --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

    - name: Check container logs for errors
      run: |
        echo "=== Web Service Logs ==="
        docker compose logs web
        echo "=== Database Logs ==="
        docker compose logs db

        # Check for critical errors
        if docker compose logs web | grep -i "error\|exception\|failed" | grep -v "test"; then
          echo "Found errors in web service logs"
          exit 1
        fi

    - name: Test container restart resilience
      run: |
        echo "Testing container restart..."
        docker compose restart web

        # Wait for service to come back up
        sleep 10
        curl -f http://localhost:8001/health || curl -f http://localhost:8001/

    - name: Test file upload functionality
      run: |
        # Create a test file
        echo "Test D&D session content" > test-session.txt

        # Test file upload endpoint (may return 404 if not implemented, that's ok)
        curl -X POST -F "file=@test-session.txt" http://localhost:8001/upload || echo "Upload endpoint not available yet"

    - name: Cleanup
      if: always()
      run: |
        docker compose down -v
        docker system prune -f

  synology-compatibility-test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Test ARM64 compatibility (Synology DS718+ simulation)
      run: |
        # Set up ARM64 emulation
        docker run --rm --privileged multiarch/qemu-user-static --reset -p yes

        # Build for ARM64 (DS718+ architecture)
        docker buildx create --use --name synology-builder
        docker buildx build \
          --platform linux/arm64 \
          --build-arg OPENAI_API_KEY=test_key \
          --build-arg DATABASE_URL=postgresql+asyncpg://user:password@db:5432/dndstory \
          -t dndstorytelling:synology \
          -f deployment/docker/Dockerfile \
          --load .

    - name: Test resource constraints (NAS simulation)
      run: |
        # Create a container with limited resources (similar to NAS constraints)
        docker run -d \
          --name synology-test \
          --memory=512m \
          --cpus=1.0 \
          -e DATABASE_URL=sqlite:///./test.db \
          -e SECRET_KEY=test_key \
          -e OPENAI_API_KEY=test_key \
          -p 8002:8000 \
          dndstorytelling:synology

    - name: Test application under resource constraints
      run: |
        # Wait for application to start
        sleep 15

        # Test basic functionality
        curl -f http://localhost:8002/health || curl -f http://localhost:8002/ || echo "Service not responding"

        # Check resource usage
        docker stats --no-stream synology-test

    - name: Test SQLite fallback (for NAS deployment option)
      run: |
        # Test that the app can work with SQLite (useful for NAS)
        docker run --rm --platform linux/arm64 \
          -e DATABASE_URL=sqlite:///./test.db \
          -e SECRET_KEY=test_key \
          -e OPENAI_API_KEY=test_key \
          dndstorytelling:synology \
          python -c "
          import sys
          print('Python import test: OK')
          try:
              from app.config import get_settings
              settings = get_settings()
              print('Config loading test: OK')
              print('SQLite compatibility: OK')
          except Exception as e:
              print(f'Config test failed (expected in test env): {e}')
              print('Basic Python execution: OK')
          "

    - name: Cleanup Synology test
      if: always()
      run: |
        docker stop synology-test || true
        docker rm synology-test || true
        docker buildx rm synology-builder || true

  security-scan:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Free up disk space
      run: |
        # Clean up disk space to avoid "no space left on device" error
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /opt/ghc
        sudo rm -rf /usr/local/share/boost
        sudo rm -rf "$AGENT_TOOLSDIRECTORY"
        docker system prune -af

    - name: Build lightweight image for security scan
      run: |
        # Build with minimal context to save space
        docker build -t dndstorytelling:security-scan \
          --build-arg OPENAI_API_KEY=test_key \
          --build-arg DATABASE_URL=sqlite:///./test.db \
          -f deployment/docker/Dockerfile \
          .

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'dndstorytelling:security-scan'
        format: 'sarif'
        output: 'trivy-results.sarif'
        # Limit scan scope to reduce disk usage
        scanners: 'vuln,secret'
        timeout: '10m'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always() && hashFiles('trivy-results.sarif') != ''
      with:
        sarif_file: 'trivy-results.sarif'

    - name: Show Trivy results summary (if SARIF upload fails)
      if: always()
      run: |
        if [ -f trivy-results.sarif ]; then
          echo "Trivy scan completed successfully"
          # Show summary without uploading to save on API calls
          docker run --rm -v $(pwd):/workspace aquasec/trivy image \
            --format table --quiet \
            dndstorytelling:security-scan || echo "Trivy table format failed"
        else
          echo "Trivy results file not found"
        fi

  comprehensive-docker-tests:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build test image
      run: |
        docker compose -f deployment/docker/docker-compose.test.yml build test

    - name: Start test database
      run: |
        docker compose -f deployment/docker/docker-compose.test.yml up -d test_db

    - name: Wait for database
      run: |
        timeout 60 bash -c 'until docker compose -f deployment/docker/docker-compose.test.yml exec -T test_db pg_isready -U test_user -d dndstory_test; do sleep 2; done'

    - name: Run database migrations
      run: |
        docker compose -f deployment/docker/docker-compose.test.yml run --rm test alembic upgrade head

    - name: Run comprehensive tests
      run: |
        docker compose -f deployment/docker/docker-compose.test.yml run --rm test python -m pytest testing/tests/ -v --tb=short --cov=app --cov-report=xml --cov-report=html

    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      if: always()
      with:
        file: ./coverage.xml
        flags: docker-tests
        name: docker-test-coverage

    - name: Archive test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: docker-test-results
        path: |
          htmlcov/
          coverage.xml

    - name: Cleanup
      if: always()
      run: |
        docker compose -f deployment/docker/docker-compose.test.yml down -v