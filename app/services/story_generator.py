import os
import logging
from typing import Dict, Any, List

from openai import AsyncOpenAI
from app.services.segmented_story_processor import SegmentedStoryProcessor

logger = logging.getLogger(__name__)

class StoryGenerationError(Exception):
    """Exception raised when story generation fails."""
    pass


class StoryGenerator(SegmentedStoryProcessor):
    def __init__(self, api_key: str):
        super().__init__(max_segment_tokens=3000, overlap_tokens=200)  # Safe limits for OpenAI
        self.client = AsyncOpenAI(api_key=api_key)

    async def generate_story(self, text: str, context) -> str:
        """
        Main entry point for story generation.
        Automatically handles large transcriptions by segmenting and processing completely.
        """
        logger.info(f"Starting OpenAI story generation for {self.estimate_tokens(text)} estimated tokens")

        # Use the segmented processing to ensure we read ALL the content
        return await self.process_full_transcription(text, context)

    async def _process_single_segment(self, segment: Dict[str, Any], context: Any) -> str:
        """Process a single segment when transcription is small enough."""
        prompt = self._create_prompt(segment['content'], context)
        return await self._generate_with_openai(prompt)

    async def _process_segment_with_context(self, segment: Dict[str, Any], context: Dict[str, Any], elements: Dict[str, Any]) -> str:
        """Process a segment with accumulated context from previous segments."""
        # Create enhanced prompt with context from previous segments
        enhanced_prompt = self._create_segment_prompt(segment['content'], context, elements, segment)
        return await self._generate_with_openai(enhanced_prompt)

    async def _synthesize_complete_story(self, segment_summaries: List[Dict[str, Any]], original_context: Any) -> str:
        """Synthesize all segment summaries into final coherent story."""
        # Combine all summaries
        all_summaries = [s['summary'] for s in segment_summaries]
        combined_content = "\n\n---\n\n".join(all_summaries)

        # Create synthesis prompt
        synthesis_prompt = self._create_synthesis_prompt(combined_content, segment_summaries, original_context)

        # Generate final unified story
        final_story = await self._generate_with_openai(synthesis_prompt)

        # Add session statistics
        total_characters = len(self.session_memory['characters'])
        total_locations = len(self.session_memory['locations'])

        header = f"""# ðŸŽ² Complete D&D Session Story

*This story was generated by processing ALL {len(segment_summaries)} segments of your session transcription, ensuring no details were missed.*

**Session Statistics:**
- Characters Identified: {total_characters}
- Locations Visited: {total_locations}
- Segments Processed: {len(segment_summaries)}
- Complete Story: Yes âœ…

---

"""

        return header + final_story

    async def _generate_with_openai(self, prompt: str) -> str:
        """Generate text using OpenAI API with fallback models."""
        # Try models in order of preference (newest to older)
        models_to_try = ["gpt-4o", "gpt-4", "gpt-4-turbo"]

        for model in models_to_try:
            try:
                response = await self.client.chat.completions.create(
                    model=model,
                    messages=[
                        {
                            "role": "system",
                            "content": "You are a creative writer specializing in D&D campaign narratives. Focus on creating engaging, detailed stories that capture the essence of tabletop RPG sessions.",
                        },
                        {"role": "user", "content": prompt},
                    ],
                    max_tokens=4000,  # Increased for better story generation
                    temperature=0.7
                )
                return response.choices[0].message.content
            except Exception as e:
                error_msg = str(e).lower()
                if "model" in error_msg and "not found" in error_msg:
                    continue  # Try next model
                elif "quota" in error_msg or "insufficient_quota" in error_msg or "429" in str(e):
                    # Quota exceeded - provide clear error message
                    raise Exception(f"OpenAI quota exceeded (Error 429). Please check your plan and billing details at https://platform.openai.com/account/billing")
                elif "401" in str(e) or "authentication" in error_msg:
                    # Authentication error
                    raise Exception("OpenAI API key authentication failed. Please check your API key.")
                else:
                    raise e  # Re-raise other errors

        # If all models fail, raise the last error
        raise Exception(f"None of the available models ({', '.join(models_to_try)}) are accessible with your API key. Please check your OpenAI account and subscription.")

    def _create_prompt(self, text: str, context) -> str:
        # Handle both dict and StoryContext model
        if hasattr(context, 'model_dump'):
            # Pydantic model
            session_name = getattr(context, 'session_name', 'Unknown Session')
            setting = getattr(context, 'setting', 'generic fantasy')
            characters = getattr(context, 'characters', [])
            previous_events = getattr(context, 'previous_events', [])
            campaign_notes = getattr(context, 'campaign_notes', None)
        else:
            # Dictionary fallback for legacy tests
            session_name = context.get('session_name', 'Unknown Session')
            setting = context.get('setting', 'generic fantasy')
            characters = context.get('characters', [])
            previous_events = context.get('previous_events', [])
            campaign_notes = context.get('campaign_notes', None)

        characters_str = ', '.join(characters) if characters else 'Unknown characters'
        previous_str = '. '.join(previous_events) if previous_events else 'No previous events'
        notes_str = campaign_notes if campaign_notes else 'No additional notes'

        return f"""
        Based on this D&D session transcript:
        {text}

        Create a narrative with these specifications:
        Session: {session_name}
        Setting: {setting}
        Characters: {characters_str}
        Previous Events: {previous_str}
        Campaign Notes: {notes_str}

        Please create an engaging narrative summary of this session.
        """

    def _create_segment_prompt(self, text: str, context: Dict[str, Any], elements: Dict[str, Any], segment_info: Dict[str, Any]) -> str:
        """Create prompt for processing a segment with context from previous segments."""
        session_name = context.get('session_name', 'Unknown Session')
        setting = context.get('setting', 'D&D Fantasy')
        characters = context.get('characters', [])
        previous_events = context.get('previous_events', [])

        characters_str = ', '.join(characters) if characters else 'Unknown characters'
        previous_str = '. '.join(previous_events) if previous_events else 'Beginning of session'

        # Include discovered elements from this segment
        segment_characters = ', '.join(elements['characters']) if elements['characters'] else 'None discovered'
        segment_locations = ', '.join(elements['locations']) if elements['locations'] else 'None specified'

        return f"""You are processing segment {segment_info['segment_id']} of {segment_info['total_segments']} from a D&D session.

Session Context:
- Session: {session_name}
- Setting: {setting}
- Known Characters: {characters_str}
- What Happened Previously: {previous_str}

This Segment Contains:
- Characters Active: {segment_characters}
- Locations: {segment_locations}
- Segment: {segment_info['segment_id']}/{segment_info['total_segments']}

Segment Content:
{text}

Create a detailed narrative for this segment that:
1. Connects to previous events
2. Captures all character actions and dialogue
3. Describes the setting and atmosphere vividly
4. Maintains story continuity
5. Sets up for the next segment (if not final)

Focus on this segment while being aware of the larger story context."""

    def _create_synthesis_prompt(self, combined_content: str, segment_summaries: List[Dict[str, Any]], original_context: Any) -> str:
        """Create prompt for synthesizing all segments into final story."""
        if hasattr(original_context, 'model_dump'):
            session_name = getattr(original_context, 'session_name', 'Epic D&D Session')
            setting = getattr(original_context, 'setting', 'D&D Fantasy')
            campaign_notes = getattr(original_context, 'campaign_notes', None)
        else:
            session_name = original_context.get('session_name', 'Epic D&D Session') if original_context else 'Epic D&D Session'
            setting = original_context.get('setting', 'D&D Fantasy') if original_context else 'D&D Fantasy'
            campaign_notes = original_context.get('campaign_notes', None) if original_context else None

        all_characters = list(self.session_memory['characters'])
        all_locations = list(self.session_memory['locations'])

        characters_str = ', '.join(all_characters) if all_characters else 'Various adventurers'
        locations_str = ', '.join(all_locations) if all_locations else 'Multiple locations'
        notes_str = campaign_notes if campaign_notes else 'Complete session analysis'

        return f"""You are creating a final, unified story from {len(segment_summaries)} processed segments of a D&D session.

Complete Session Information:
- Session: {session_name}
- Setting: {setting}
- All Characters: {characters_str}
- All Locations: {locations_str}
- Campaign Notes: {notes_str}
- Total Segments: {len(segment_summaries)}

All Segment Summaries:
{combined_content}

Create a comprehensive, unified narrative that:
1. Weaves all segments into one coherent story
2. Maintains proper chronological order
3. Develops character arcs throughout the session
4. Builds dramatic tension and resolution
5. Captures the complete D&D experience
6. Uses rich, immersive descriptions
7. Includes all major events and character moments

This should read as one complete D&D session story, not separate segments."""

    def _preprocess_transcription(self, transcription: str) -> str:
        """Preprocess transcription text for better story generation."""
        if not transcription or not transcription.strip():
            return ""

        # Clean up common transcription artifacts
        cleaned = transcription.strip()

        # Remove excessive whitespace
        cleaned = ' '.join(cleaned.split())

        # Basic punctuation cleanup
        cleaned = cleaned.replace(' ,', ',')
        cleaned = cleaned.replace(' .', '.')
        cleaned = cleaned.replace(' ?', '?')
        cleaned = cleaned.replace(' !', '!')

        return cleaned

    def validate_context(self, context):
        """Validate and normalize context parameters."""
        # If it's already a StoryContext model, return as-is
        if hasattr(context, 'model_dump'):
            return context

        # Handle dictionary input for backwards compatibility
        if isinstance(context, dict):
            from app.models.story import StoryContext

            # Map old context fields to new StoryContext fields
            session_name = context.get('session_name', 'D&D Session')
            setting = context.get('world', context.get('setting', 'generic fantasy'))
            characters = context.get('characters', [])
            previous_events = context.get('previous_context', [])
            if isinstance(previous_events, str) and previous_events != 'none':
                previous_events = [previous_events]
            elif previous_events == 'none':
                previous_events = []

            campaign_notes = context.get('campaign_notes', None)

            return StoryContext(
                session_name=session_name,
                setting=setting,
                characters=characters,
                previous_events=previous_events,
                campaign_notes=campaign_notes
            )

        return context
