"""
Demo Story Generator for testing purposes
This creates enhanced D&D stories without requiring OpenAI API
Now with comprehensive transcription processing to ensure no content is missed
"""

from typing import Dict, Any, List
import logging
import random

from app.services.segmented_story_processor import SegmentedStoryProcessor

logger = logging.getLogger(__name__)

class DemoStoryGenerator(SegmentedStoryProcessor):
    """Demo story generator that creates enhanced D&D narratives without API calls"""

    def __init__(self):
        super().__init__(max_segment_tokens=2000, overlap_tokens=100)  # Smaller segments for demo mode
        self.enhancement_templates = {
            'combat': [
                "The clash of steel rang through the air as",
                "With a thunderous roar, the battle erupted when",
                "The tension broke like a snapped bowstring as",
                "In a moment of deadly silence before the storm,"
            ],
            'dialogue': [
                "The words hung heavy in the air:",
                "With determination gleaming in their eyes, they declared:",
                "The voice echoed with authority and purpose:",
                "In hushed, urgent tones, the warning came:",
            ],
            'atmosphere': [
                "The ancient stones seemed to whisper of forgotten secrets,",
                "An otherworldly presence filled the chamber,",
                "The very air crackled with magical energy as",
                "Shadows danced ominously across the walls while",
            ]
        }

    async def generate_story(self, text: str, context: Dict[str, Any] = None) -> str:
        """
        Generate story using demo mode with comprehensive transcription processing.
        Ensures ALL content is processed regardless of size.
        """
        logger.info(f"Starting demo story generation for {self.estimate_tokens(text)} estimated tokens")

        # Use segmented processing to ensure we handle large transcriptions completely
        return await self.process_full_transcription(text, context)

    async def _process_single_segment(self, segment: Dict[str, Any], context: Any) -> str:
        """Process a single segment when transcription is small enough."""
        session_name = "Demo Session"
        if context and 'session_name' in context:
            session_name = context['session_name']
        return self.enhance_story(segment['content'], session_name)

    async def _process_segment_with_context(self, segment: Dict[str, Any], context: Dict[str, Any], elements: Dict[str, Any]) -> str:
        """Process a segment with accumulated context from previous segments."""
        session_name = context.get('session_name', 'Demo Session')

        # Enhanced processing for segments with context
        enhanced_content = self.enhance_story_with_context(
            segment['content'],
            session_name,
            context,
            elements,
            segment
        )
        return enhanced_content

    async def _synthesize_complete_story(self, segment_summaries: List[Dict[str, Any]], original_context: Any) -> str:
        """Synthesize all segment summaries into final coherent story."""
        session_name = "Epic Demo Session"
        if original_context:
            if hasattr(original_context, 'session_name'):
                session_name = original_context.session_name
            elif isinstance(original_context, dict):
                session_name = original_context.get('session_name', session_name)

        # Combine all segment stories
        all_stories = [s['summary'] for s in segment_summaries]

        # Create comprehensive final story
        total_characters = len(self.session_memory['characters'])
        total_locations = len(self.session_memory['locations'])

        header = f"""# üé≤ Complete D&D Session Story (Demo Mode)

*This comprehensive story was generated by processing ALL {len(segment_summaries)} segments of your session transcription, ensuring complete coverage.*

**Session Statistics:**
- Characters Identified: {total_characters}
- Locations Visited: {total_locations}
- Segments Processed: {len(segment_summaries)}
- Complete Story: Yes ‚úÖ
- Mode: Enhanced Demo (No API Required) üÜì

---

## {session_name}

"""

        # Weave segments together with enhanced transitions
        final_story = header

        for i, story in enumerate(all_stories):
            if i > 0:
                # Add transition between segments
                transitions = [
                    "\n\n### Continuing the Adventure...\n\n",
                    "\n\n### As the Story Unfolds...\n\n",
                    "\n\n### The Adventure Continues...\n\n",
                    "\n\n### Meanwhile, in the ongoing tale...\n\n"
                ]
                final_story += random.choice(transitions)

            final_story += story

        # Add epic conclusion
        final_story += f"""\n\n### üåü Session Summary

This epic {session_name} showcased the full breadth of D&D storytelling, with our heroes encountering challenges across {len(segment_summaries)} major scenes. The adventure featured {total_characters} distinct characters across {total_locations} memorable locations.

*Every moment of the session was captured and woven into this complete narrative - no detail was left behind!*"""

        return final_story

    async def process_audio(self, audio_path: str) -> str:
        """Process audio using demo mode - fallback when used as unified service"""
        from app.services.demo_audio_processor import DemoAudioProcessor
        demo_audio = DemoAudioProcessor()
        return await demo_audio.process_audio(audio_path)

    def enhance_story(self, original_text: str, session_name: str = "Unknown Session") -> str:
        """Create an enhanced version of the original D&D session text"""

        # Extract key elements
        has_combat = any(word in original_text.lower() for word in ['combat', 'battle', 'attack', 'damage', 'roll', 'initiative'])
        has_dialogue = '"' in original_text or "'" in original_text
        has_magic = any(word in original_text.lower() for word in ['magic', 'spell', 'cast', 'wizard', 'cleric'])

        # Create enhanced narrative
        enhanced_story = f"""# üé≤ Enhanced D&D Story: {session_name}

## ‚ú® AI-Enhanced Narrative

*The following story has been crafted from your session notes, with enhanced descriptions, dramatic tension, and rich narrative elements that bring your D&D adventure to life.*

---

"""

        # Add atmospheric opening
        if 'keep' in original_text.lower() or 'fortress' in original_text.lower():
            enhanced_story += random.choice(self.enhancement_templates['atmosphere']) + " the ancient fortress loomed before our heroes.\n\n"
        elif 'dungeon' in original_text.lower() or 'cavern' in original_text.lower():
            enhanced_story += random.choice(self.enhancement_templates['atmosphere']) + " the depths beckoned with promise and peril.\n\n"
        else:
            enhanced_story += random.choice(self.enhancement_templates['atmosphere']) + " the adventure began to unfold.\n\n"

        # Process the original text and enhance key moments
        lines = original_text.split('\n')
        in_combat = False

        for line in lines:
            line = line.strip()
            if not line:
                enhanced_story += "\n"
                continue

            # Enhance combat sections
            if any(word in line.lower() for word in ['initiative', 'attack', 'damage', 'combat encounter']):
                if not in_combat:
                    enhanced_story += f"\n{random.choice(self.enhancement_templates['combat'])} "
                    in_combat = True
                enhanced_story += f"**{line}**\n\n"
                enhanced_story += "*The battlefield erupted into controlled chaos, each combatant moving with deadly precision and purpose.*\n\n"

            # Enhance dialogue
            elif '"' in line or line.endswith('"):') or line.endswith("'):"):
                enhanced_story += f"{random.choice(self.enhancement_templates['dialogue'])} \n\n"
                # Fix f-string backslash issue by using separate variable
                clean_line = line.replace('"', '')
                enhanced_story += f"*\"{clean_line}\"*\n\n"

            # Enhance DM descriptions
            elif line.startswith('DM:'):
                enhanced_story += f"**The Dungeon Master's Voice:** {line[3:].strip()}\n\n"
                enhanced_story += "*The scene unfolds with vivid detail, drawing the players deeper into the immersive world.*\n\n"

            # Regular lines
            else:
                enhanced_story += f"{line}\n\n"

        # Add epic conclusion
        enhanced_story += """
---

## üåü Session Highlights

**Epic Moments:** This session showcased incredible teamwork, strategic thinking, and memorable roleplay that will be remembered for campaigns to come.

**Character Development:** Each hero grew not just in power, but in the bonds that tie them together as a legendary adventuring party.

**World Building:** The rich tapestry of this fantasy realm continues to unfold, with new mysteries and adventures waiting beyond every door.

*This enhanced narrative captures the spirit and excitement of your D&D session, transforming raw notes into an epic tale worthy of the greatest fantasy adventures.*

---

üí° **Free Version Active:** This is a complete free AI enhancement! For even more advanced features, you can optionally install Ollama for local AI processing that never leaves your computer.
"""

        return enhanced_story

    def enhance_story_with_context(self, text: str, session_name: str, context: Dict[str, Any], elements: Dict[str, Any], segment_info: Dict[str, Any]) -> str:
        """Enhanced story generation with context from previous segments."""

        # Get context information
        previous_events = context.get('previous_events', [])
        known_characters = context.get('characters', [])

        # Create enhanced segment story
        segment_num = segment_info['segment_id']
        total_segments = segment_info['total_segments']

        enhanced_story = f"""## üìñ Part {segment_num} of {total_segments}: {session_name}

"""

        # Add context connection if not first segment
        if segment_num > 1 and previous_events:
            enhanced_story += f"*Building on the previous events: {previous_events[-1][:100]}...*\n\n"

        # Add atmospheric elements based on discovered content
        if elements['locations']:
            location = list(elements['locations'])[0]
            enhanced_story += f"üè∞ **Setting**: The adventure continues in {location}, where "

        if elements['characters']:
            main_char = list(elements['characters'])[0]
            enhanced_story += f"{main_char} takes center stage as "

        # Process the actual content with enhancements
        base_story = self.enhance_story(text, f"{session_name} - Part {segment_num}")

        # Remove the header from base story if present
        if base_story.startswith("# üé≤"):
            lines = base_story.split('\n')
            # Find where content actually starts
            content_start = 0
            for i, line in enumerate(lines):
                if line.strip() and not line.startswith('#') and not line.startswith('*') and '---' not in line:
                    content_start = i
                    break
            base_story = '\n'.join(lines[content_start:])

        enhanced_story += base_story

        # Add segment conclusion with setup for next part
        if not segment_info.get('is_final', False):
            enhanced_story += f"\n\n*The adventure continues in Part {segment_num + 1}...*"
        else:
            enhanced_story += "\n\n*The epic session reaches its thrilling conclusion!*"

        return enhanced_story

# Create a global instance for use in the application
demo_generator = DemoStoryGenerator()